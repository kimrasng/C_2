#include	<stdio.h>

int main(void)
{
	//	비트연선자(&, |, ^, ~, <<, >>)

	/*
	printf("10 & 7 = %d\n", 10 & 7);	//	10과 7의 비트 논리곱(AND)을 수행한다.
	printf("10 | 7 = %d\n", 10 | 7);	//	10과 7의 비트 논리합(OR)을 수행한다
	printf("10 ^ 7 = %d\n", 10 ^ 7);	//	10과 7의 비트 배타적 논리합 (XOR)을 수행한다.

	printf("123 & 456 = %d\n", 123 & 456);	//	123과 456의 비트 논리곱(AND)을 수행한다.
	printf("123 | 456 = %d\n", 123 | 456);	//	123과 456의 비트 논리합(OR)을 수행한다.
	printf("123 ^ 456 = %d\n", 123 ^ 456);	//	123과 456의 비트 재타적 논리합(XOR)을 수행한다.

	printf("0xFFFF & 0000 = %d\n", 0xFFFF & 0000);	//	0xFFFF과 0000의 비트 논리곱(AND)을 수행한다.
	printf("0xFFFF | 0000 = %d\n", 0xFFFF | 0000);	//	0xFFFF과 0000의 비트 논리합(OR)을 수행한다.
	printf("0xFFFF ^ 0000 = %d\n", 0xFFFF ^ 0000);	//	0xFFFF과 0000의 비트 재타적 논리합(XOR)을 수행한다.
	*/

	/*
	비트 연산자
		비트 연산자는 정수나 문자 등을 2진수로 변환한 후에 각 자리의 비트끼리 연산 수행
		비트 연산자의 종류
			&(비트 논리곱), |(비트 논리 합), ^(비트 배타적논리합), ~(비트부정), <<(비트 왼쪽 시프트), >>(비트 오른쪽 시프트)
		비트 논리곱(&) 연산자 : 둘다 참일떄 참
			10진수를 2진수로 변환한후 각 비트에 OR 연산 수행
		비트 배타적 논리합(^) 연산자
			두 값이 다르면 참(1),같으면 거짓(0)
				'참(1) ^ 참(1)' 이나 '거짓(0) ^ 거짓(0)' 이러면 결과는 거짓 (0)
				'참(1) ^ 거짓(0)' 이나 '거짓(0) ^ 참(1)' 이러면 결과는 참 (1)
	*/

	/*
	char a = 'A', b, c;
	char mask = 0x0F;	//	마스크 값 (0000 1111)을 설정한다

	printf("%X & %X = %x\n", a, mask, a & mask);	//	'A'와 0x0F의 논리곱을 수행한다.
	printf("%X | %X = %x\n", a, mask, a | mask);	//	'A'와 0X0F의 논리합을 수행한다.

	mask = 'a' - 'A';	//	'a'(97)와 'A'(65)의 차이는 32이다.

	b = a ^ mask;	//	'A'와 마스크(32)의 배타적 논리합을 수행한다.
	printf("%c ^ %d = %c\n", a, mask, b);
	
	a = b ^ mask;	//	'a'와 마스크(32)의 배타적 논리합을 수행한다.
	printf("%c ^ %d = %c\n", b, mask, a);
	*/

	/*
	int a = 10;

	printf("%d\n", ~a + 1);	//	반대수를 구할떄는 2의 보수를 사용한다.
	/*
	비트 부정(~) 연산자
		두 수에 대한 연산이 아니라 비트 하나의 값을 반대로 만든다.
		어떤 수의 음숫값(-)을 찾을 떄 사용
		2의 보수(음수) = { 1의 보수(각 비트의 값을 반전시킨 값) } +1
	*/
	
	/*
	int a = 10;

	printf("%d를 왼쪽으로 1회 시프트하면 %d이다\n", a, a << 1);
	printf("%d를 왼쪽으로 2회 시프트하면 %d이다\n", a, a << 2);
	printf("%d를 왼쪽으로 3회 시프트하면 %d이다\n", a, a << 3);
	/*
	비트 왼쪽 시프트 (<<) 연산자
		나열된 비트를 왼쪽으로 시프트(shift)하는 연산자
		왼쪽 시프트를 할 때마낟 2의1승, 2의2승, 2의3승....을 곱한 효과
		왼쪽 n번 시프트를 할 떄는 2의 n승(2의 1승, 2의 2승, 2의 3승...)을 곱한 효과
	*/

	int a = 10;

	printf("%d를 오른쪽으로 1회 시프트하면 %d이다\n", a, a >> 1);
	printf("%d를 오른쪽으로 2회 시프트하면 %d이다\n", a, a >> 2);
	printf("%d를 오른쪽으로 3회 시프트하면 %d이다\n", a, a >> 3);

	/*
	비트 오른쪽 시프트(>>) 연산자
		나열된 비트를 오른쪽으로 시프트하는 연산자
		오른쪽으로 시프트할 때마다 2n(2의 1승, 2의 2승, 2의 3승...)으로 나눈 효과
		오른쪽 시프트를 할 때 마다 2의 n승(2의 1승, 2의 2승, 2의 3승...)을 나눈 몫의 효과
	*/

	return 0;
}